singletop和singletask模式下
	会回调onNewIntent方法

================================================================
线程的两种启动方式
	第一种(不可共享全局变量)：class MyThread1 extends Thread:
		MyThread1 th1 = new MyThread1();
		th1.start();

	第二种(可以共享全局变量，但线程不安全)：class MyThread2 implements Runnable
		MyThread2 my = new MyThread2();
		Thread run3 = new Thread(my);
		run3.start();

=================================================================
String 字符串常量(一直用+进行拼接字符串的话，会不停的开辟内存空间)
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）

速度: StringBuilder > StringBuffer > String
=================================================================
view绘制的步骤
	View的整个绘制流程可以分为以下三个阶段：
		measure: 判断是否需要重新计算View的大小，需要的话则计算；
		layout: 判断是否需要重新计算View的位置，需要的话则计算；
		draw: 判断是否需要重新绘制View，需要的话则重绘制。

=================================================================
单例模式
	使用以下方法，避免的了线程不安全
	private static final Singleton1 single = new Singleton1();    
    public static Singleton1 getInstance() {  
        return single;  
    } 
    如果要使用懒加载，需要对他进行优化
    1.在方法 getInstance上加同步synchronized
    2.双重检查锁定
    public static Singleton getInstance() {  
        if (singleton == null) {    
            synchronized (Singleton.class) {    
               if (singleton == null) {    
                  singleton = new Singleton();   
               }    
            }    
        }    
        return singleton;   
    }  
    3.使用静态内部类
    private static class LazyHolder {    
       private static final Singleton INSTANCE = new Singleton();    
    }    
    private Singleton (){}    
    public static final Singleton getInstance() {    
       return LazyHolder.INSTANCE;    
    }    
=================================================================
工厂模式，抽象工厂模式，装饰模式，观察者模式
=================================================================
android 升级数据库（https://blog.csdn.net/qq_35114086/article/details/53319093）
	修改数据库后, +1 . 调用onUpgrade方法.

	将现有表重命名为临时表；
	创建新表；
	将临时表的数据导入新表（注意处理修改的列）；
	删除临时表。

	方式一：确定 相邻版本 的差别，从版本1开始依次迭代更新，先执行v1到v2，再v2到v3……
	方式二：为 每个版本 确定与现在数据库的差别，为每个case撰写专门的升级代码。
=================================================================
invalidate与postInvalidate区别
	在UI主线程中，用invalidate()；本质是调用View的onDraw（）绘制。
	主线程之外，用postInvalidate()。
=================================================================
进程和线程的区别
	进程是程序执行时的一个实例，程序运行时系统就会创建一个进程。
	线程是进程的一个执行流。
	进程可以包含多个线程。
	多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响。
=================================================================
线程池（https://www.cnblogs.com/dolphin0520/p/3932921.html
		https://blog.csdn.net/qq_34952110/article/details/78086085）
	最核心的类是：ThreadPoolExecutor，execute()又是ThreadPoolExecutor的核心方法
	1）corePoolSize：线程池的基本大小
	2）maximumPoolSize：线程池中允许的最大线程数
	3）poolSize：当前线程的数量
	4）allowCoreThreadTimeOut：如果线程池的大小已经达到了corePoolSize，不管有没有任务需要执行，线程池都会保证这些核心线程处于存活状态
	5）keepAliveTime：一个线程处在空闲状态的时间超过了该属性值，就会因为超时而退出。如果线程池的核心大小corePoolSize=5，而当前大小poolSize =8，那么超出核心大小的线程，会退出。如果线程池的核心大小corePoolSize=5，而当前大小poolSize =5，那么线程池中所有线程都是核心线程，这个时候线程是否会退出，取决于allowCoreThreadTimeOut。
	
	1、默认情况下，在创建了线程池后，线程池中的线程数为0，除非调用了prestartAllCoreThreads()或者prestartCoreThread()方法，进行预创建
	2、当前线程池工作线程数量还没有达到基本大小(poolSize < corePoolSize)，那么就新增加一个线程处理新提交的任务
	3、如果当前线程池工作线程数量已经达到了基本大小，就将新提交的任务提交到阻塞队列排队，等候处理workQueue.offer(command)
	4、如果队列容量已达上限，并且当前大小poolSize没有达到maximumPoolSize，那么就新增线程来处理任务
	5、如果队列已满，并且当前线程数目也已经达到上限，此时需要拒绝新增加的任务，如何拒绝，需要取决于线程池的饱和策略RejectedExecutionHandler

一般不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池
	Executors.newCachedThreadPool(); 创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE
	Executors.newSingleThreadExecutor();   创建容量为1的缓冲池
	Executors.newFixedThreadPool(int);     创建固定容量大小的缓冲池
	Executors.newScheduledThreadPool(int);  有延迟执行和周期重复执行的线程池
=================================================================
looper和messagequeue的关系（https://blog.csdn.net/itheimach/article/details/52050910）
	一个线程只有一个looper
	Looper构造器中创建MessageQueue对象
	handler可以有多个
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
