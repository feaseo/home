singletop和singletask模式下
	会回调onNewIntent方法

================================================================
线程的两种启动方式
	第一种(不可共享全局变量)：class MyThread1 extends Thread:
		MyThread1 th1 = new MyThread1();
		th1.start();

	第二种(可以共享全局变量，但线程不安全)：class MyThread2 implements Runnable
		MyThread2 my = new MyThread2();
		Thread run3 = new Thread(my);
		run3.start();

=================================================================
String 字符串常量(一直用+进行拼接字符串的话，会不停的开辟内存空间)
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）

速度: StringBuilder > StringBuffer > String
=================================================================
view绘制的步骤
	View的整个绘制流程可以分为以下三个阶段：
		measure: 判断是否需要重新计算View的大小，需要的话则计算；
		layout: 判断是否需要重新计算View的位置，需要的话则计算；
		draw: 判断是否需要重新绘制View，需要的话则重绘制。

=================================================================
单例模式
	使用以下方法，避免的了线程不安全
	private static final Singleton1 single = new Singleton1();    
    public static Singleton1 getInstance() {  
        return single;  
    } 
    如果要使用懒加载，需要对他进行优化
    1.在方法 getInstance上加同步synchronized
    2.双重检查锁定
    public static Singleton getInstance() {  
        if (singleton == null) {    
            synchronized (Singleton.class) {    
               if (singleton == null) {    
                  singleton = new Singleton();   
               }    
            }    
        }    
        return singleton;   
    }  
    3.使用静态内部类
    private static class LazyHolder {    
       private static final Singleton INSTANCE = new Singleton();    
    }    
    private Singleton (){}    
    public static final Singleton getInstance() {    
       return LazyHolder.INSTANCE;    
    }    
=================================================================
工厂模式，抽象工厂模式，装饰模式，观察者模式
=================================================================
android 升级数据库（https://blog.csdn.net/qq_35114086/article/details/53319093）
	修改数据库后, +1 . 调用onUpgrade方法.

	将现有表重命名为临时表；
	创建新表；
	将临时表的数据导入新表（注意处理修改的列）；
	删除临时表。

	方式一：确定 相邻版本 的差别，从版本1开始依次迭代更新，先执行v1到v2，再v2到v3……
	方式二：为 每个版本 确定与现在数据库的差别，为每个case撰写专门的升级代码。
=================================================================
invalidate与postInvalidate区别
	在UI主线程中，用invalidate()；本质是调用View的onDraw（）绘制。
	主线程之外，用postInvalidate()。
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
